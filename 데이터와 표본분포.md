## 데이터와 표본분포

### 표본분포

- 하나의 동일한 모집단에서 얻은 여러 샘플에 대한 표본통계량의 분포
- 평균과 같은 표본통계량의 분포는 데이터 자체의 분포보다 규칙적이고 종 모양일 가능성이 높음
- 표본이 클수록 표본통계량의 분포가 좁아짐
- 데이터의 값 1000개 표본, 5개 값의 평균 1000개 표본, 20개 값의 평균 1000개 표본을 비교

```r
library(ggplot2)

samp_data <- data.frame(income=sample(loans_income, 1000), type="data_dist")

samp_mean05 <- data.frame(income=tapply(sample(loans_income, 1000 * 5), rep(1:1000, each=5), FUN=mean),
                          type="mean_of_5")

samp_mean20 <- data.frame(income=tapply(sample(loans_income, 1000 * 20), rep(1:1000, each=20), FUN=mean),
                          type="mean_of_20")

income <- rbind(samp_data, samp_mean05, samp_mean20)
income$type <- factor(income$type, levels=c("data_dist", "mean_of_5", "mean_of_20"),
                      labels=c("Data", "Mean of 5", "Mean of 20"))

ggplot(income, aes(x=income)) + geom_histogram(bins=40) + facet_grid(type ~ .)
```

<img src="https://user-images.githubusercontent.com/58063806/131957139-4bed42ac-ae79-42e8-b487-2ffc8d56353f.png" width=75% />

```python
sample_data = pd.DataFrame({"income": [loan_income.sample(1000)], "type": "Data"})

sample_mean_05 = pd.DataFrame({"income": [loan_income.sample(5).mean() for _ in range(1000)], "type": "Mean of 5"})

sample_mean_20 = pd.DataFrame({"income": [loan_income.sample(20).mean() for _ in range(1000)], "type": "Mean of 20"})

results = pd.concat([sample_data, sample_mean_05, sample_mean_20], axis=0)

g = sns.FacetGrid(results, col="type", col_wrap=1, height=2, aspect=4)
g.map(plt.hist, 'income', range=[0, 200000], bins=40)
g.set_axis_labels("Income", "Count")
g.set_titles("{col_name}")
```

<img src="https://user-images.githubusercontent.com/58063806/131957277-a82acd5f-daa3-4d6c-8412-1dfc9762f82c.png" width=75% />

- 평균을 산출하는 샘플의 개수가 많아질수록 히스토그램은 갈수록 좁고 종 모양을 형성

> #### 중심극한정리
>
> 모집단이 정규분포가 아니더라도, 표본크기가 충분하고 데이터가 정규성을 크게 이탈하지 않는 경우, 여러 표본에서 추출한 평균은 종 모양의 정규분포를 형성
>
> #### 표준오차
>
> 표본 측정 지표의 변동성을 측정 (표본통계량의 변동성을 요약)



### 부트스트랩

- 현재 있는 표본에서 추가적으로 표본을 복원추출하고 각 표본에 대한 통계량과 모델을 다시 계산
  - 각 원소가 뽑힐 확률은 그대로 유지하면서 무한한 크기의 모집단을 만들어낼 수 있음
- 부트스트랩 반복 횟수가 많을수록 표준오차나 신뢰구간에 대한 추정이 더 정확해짐

```R
library(boot)

stat_fun <- function(x, idx) median(x[idx])
boot_obj <- boot(loans_income, R=1000, statistic=stat_fun)
boot_obj

# Call:
# boot(data = loans_income, statistic = stat_fun, R = 1000)

# Bootstrap Statistics :
#     original   bias    std. error
# t1*    62000 -71.0395    212.4866
```

```python
from sklearn.utils import resample

results = []
for nrepeat in range(1000):
    sample = resample(loan_income)
    results.append(sample.median())

results = pd.Series(results)
print("Bootstrap Statistics:")
print(f"original: {loan_income.median()}")
print(f"bias: {results.mean() - loan_income.median()}")
print(f"std. error: {results.std()}")

# Bootstrap Statistics:
# original: 62000.0
# bias: -77.27749999999651
# std. error: 220.5330101193522
```

- 중간값의 원래 추정치는 62000으로 부트스트랩의 분포는 추정치에서 bias만큼의 편향이 있고 std. error만큼의 표준오차가 존재



### QQ plot

- 표본이 특정 분포(정규 분포)에 얼마나 가까운지를 시각적으로 판별
- z-score를 오름차순으로 정렬하고 각 값의 z 점수를 y축에 표시, x축은 정규분포에서의 해당 분위수
- 점들이 대각선 위에 놓이면 표본분포가 정규분포에 가까운 것으로 간주

```R
norm_samp <- rnorm(100)
qqnorm(norm_samp)
# a - 절편, b - 기울기
abline(a=0, b=1, col="grey")
```

<img src="https://user-images.githubusercontent.com/58063806/131963377-b58a6993-9769-4e28-af92-28ca30e932eb.png" width=70% />

```python
from scipy import stats
from scipy.stats import probplot

fig, axes = plt.subplots(figsize=(10, 8))
norm_sample = stats.norm.rvs(size=100)
probplot(norm_sample, plot=axes)
axes.set_title("Normal Q-Q plot")
```

<img src="https://user-images.githubusercontent.com/58063806/131964208-2562f895-8495-4187-89f0-8fb4dfdc7105.png" width=70% />

> **원시 데이터 자체는 대게 정규분포가 아니지만 표본들의 평균과 합계 그리고 오차는 대다수 정규분포를 따름**



#### 긴꼬리 분포

- 대칭 및 비대칭 분포 모두 긴 꼬리를 가질 수 있음
  - 꼬리 : 적은 수의 극단값이 주로 존재하는 도수분포의 길고 좁은 부분
  - 왜도 : 분포의 한쪽 꼬리가 반대쪽 다른 꼬리보다 긴 정도

```R
nflx <- sp500_px[, "NFLX"]
nflx <- diff(log(nflx[nflx > 0]))

qqnorm(nflx)
abline(a=0, b=1, col="grey")
```

<img src="https://user-images.githubusercontent.com/58063806/131978906-667779d9-3885-4012-b257-a740c1185839.png" width=70% />

```python
nflx = sp500_px.NFLX
nflx = np.diff(np.log(nflx[nflx > 0]))
fig, axes = plt.subplots(figsize=(10, 8))
probplot(nflx, plot=axes)
axes.set_title("Normal Q-Q plot")
```

<img src="https://user-images.githubusercontent.com/58063806/131979419-2ccb12fc-67ad-4ab0-a01a-914f8e0fe3c4.png" width=70%/>

- 위의 데이터는 정규분포를 따르지 않으며 정규분포를 따른다고 할 때 예상되는 것보다 훨씬 더 많은 극단값을 관찰할 가능성이 있음을 의미

